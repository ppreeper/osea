

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation. &#8212; Enterprise Architecture  documentation</title>
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="boost_your_crowdfunding_campaign_with_these_10_tips.html" />
    <link rel="prev" title="6 ways to increase buy-in from project stakeholders" href="6 ways to increase buy-in from project stakeholders.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="boost_your_crowdfunding_campaign_with_these_10_tips.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="6 ways to increase buy-in from project stakeholders.html" title="6 ways to increase buy-in from project stakeholders"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Enterprise Architecture  documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.</a><ul>
<li><a class="reference internal" href="#source-javascript">[source,javascript</a></li>
<li><a class="reference internal" href="#id3">});</a></li>
<li><a class="reference internal" href="#id4">[source,javascript]</a></li>
<li><a class="reference internal" href="#id5">[source,javascript]</a></li>
<li><a class="reference internal" href="#the-promise-was-rejected-by-using-reject-function">// The promise was rejected by using reject function.</a></li>
<li><a class="reference internal" href="#id6">[source,javascript]</a></li>
<li><a class="reference internal" href="#id7">);</a></li>
<li><a class="reference internal" href="#id8">[source,javascript]</a></li>
<li><a class="reference internal" href="#id9">);</a></li>
<li><a class="reference internal" href="#id10">[source,javascript]</a></li>
<li><a class="reference internal" href="#delay-5000-then-console-log-resolved-after-5-seconds">delay(5000).then(() =&gt; console.log(‘Resolved after 5 seconds’));</a></li>
<li><a class="reference internal" href="#id11">[source,javascript]</a></li>
<li><a class="reference internal" href="#id12">[source,javascript]</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="6 ways to increase buy-in from project stakeholders.html"
                        title="previous chapter">6 ways to increase buy-in from project stakeholders</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="boost_your_crowdfunding_campaign_with_these_10_tips.html"
                        title="next chapter">&lt;no title&gt;</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/misc/a_simple_guide_to_es6_promises.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>= A Simple Guide to ES6 Promises</p>
<p>Promises are one of the most exciting additions to JavaScript ES6. For supporting asynchronous programming, JavaScript uses callbacks, link:http://exploringjs.com/es6/ch_async.html#sec_receiving-results-asynchronously[among other things]. However, callbacks suffer from problems like link:http://callbackhell.com/[Callback Hell]/link:https://en.wikipedia.org/wiki/Pyramid_of_doom_%28programming%29[Pyramid of Doom]. Promises are a pattern that greatly simplifies asynchronous programming by making the code __look__ synchronous and avoid problems associated with callbacks.</p>
<p>In this article we are going to see what are promises, and how can we leverage them to our advantage.</p>
<p>== What is a Promise?</p>
<p>The ECMA Committee defines a promise as:</p>
<div class="section" id="a-promise-is-an-object-that-is-used-as-a-placeholder-for-the-eventual-results-of-a-deferred-and-possibly-asynchronous-computation">
<h1>A Promise is an object that is used as a placeholder for the eventual results of a deferred (and possibly asynchronous) computation.<a class="headerlink" href="#a-promise-is-an-object-that-is-used-as-a-placeholder-for-the-eventual-results-of-a-deferred-and-possibly-asynchronous-computation" title="Permalink to this headline">¶</a></h1>
<p>Simply, <strong>a promise is a container for a future value</strong>. If you think for a moment, this is exactly how you use the word <strong>promise</strong> in your normal day-to-day conversation. For example, you book a flight ticket to go to India for travelling to the beautiful hill station link:https://en.wikipedia.org/wiki/Darjeeling[Darjeeling]. After booking, you get a <strong>ticket</strong>. That __ticket__ is a <strong>promise</strong> by the airline that you will get a seat on the day of your departure. In essence, the ticket is a placeholder for a future value, namely, __the seat//.</p>
<p>Here’s another example — You <a href="#id1"><span class="problematic" id="id2">**</span></a>promise**d your friend that you would return their book link:https://en.wikipedia.org/wiki/The_Art_of_Computer_Programming[The Art of Computer Programming] after reading. Here, your words act as the placeholder. The value is the said book.</p>
<p>You can think of other promise-like examples relating to various real-life situations like waiting at a doctor’s office, ordering food at a restaurant, issuing a book in a library, among others. All involve some form of a promise. However, examples only take us so far. link:https://news.ycombinator.com/item?id=902216[Talk is cheap, so let’s see the code].</p>
<p>== Making Promises</p>
<p>We create a promise when a certain task’s completion time is uncertain or too long. For example — A network request may take anywhere between 10ms to 200ms (or more) depending on the connection’s speed. We don’t want to wait while the data is being fetched. 200ms may seem less to you but it’s a (very) long time for a computer. Promises are all about making this type of asynchrony easy and effortless. Let’s get to the basics.</p>
<p>A new promise is created by the using the <strong>Promise</strong> constructor. Like this —</p>
<div class="section" id="source-javascript">
<h2>[source,javascript<a class="headerlink" href="#source-javascript" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>const myPromise = new Promise((resolve, reject) =&gt; {</dt><dd><dl class="simple">
<dt>if (Math.random() * 100 &lt;= 90) {</dt><dd><p>resolve(‘Hello, Promises!’);</p>
</dd>
</dl>
<p>}
reject(new Error(‘In 10% of the cases, I fail. Miserably.’));</p>
</dd>
</dl>
</div>
<div class="section" id="id3">
<h2>});<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>Observe that the constructor accepts a function with two parameters. This function is called an <strong>//executor//</strong> function and it <strong>describes the computation to be done</strong>. The parameters conventionally named resolve and reject, mark successful and unsuccessful <strong>eventual</strong> completion of the executor function, respectively.</p>
<p>The resolve and reject are functions themselves and are used to send back values to the promise object. When the computation is successful or the future value is ready, we send the value back using the resolve function. <strong>We say that the promise has been __resolved//</strong>.</p>
<p>If the computation fails or encounters an error, we signal that by passing the error object in the reject function. <strong>We say that the promise has been __rejected//</strong>. reject accepts any value. However, it is recommended to pass an Error object since it helps in debugging by viewing the stacktrace.</p>
<p>In the above example, Math.random() is used to generate a random number. In 90% of the cases, the promise will be resolved (assuming equal probability distribution). It will be rejected in the rest of the cases.</p>
<p>== Using Promises</p>
<p>In the above example, we created a promise and stored it in myPromise. <strong>How can we access the the value passed by the</strong> resolve or reject <strong>function</strong>? All Promise instances have a .then() method on them. Let’s see —</p>
</div>
<div class="section" id="id4">
<h2>[source,javascript]<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>const myPromise = new Promise((resolve, reject) =&gt; {</dt><dd><dl class="simple">
<dt>if (Math.random() * 100 &lt; 90) {</dt><dd><p>console.log(‘resolving the promise …’);
resolve(‘Hello, Promises!’);</p>
</dd>
</dl>
<p>}
reject(new Error(‘In 10% of the cases, I fail. Miserably.’));</p>
</dd>
</dl>
<p>});</p>
<p>// Two functions
const onResolved = (resolvedValue) =&gt; console.log(resolvedValue);
const onRejected = (error) =&gt; console.log(error);</p>
<p>myPromise.then(onResolved, onRejected);</p>
<p>// Same as above, written concisely
myPromise.then((resolvedValue) =&gt; {</p>
<blockquote>
<div><p>console.log(resolvedValue);</p>
</div></blockquote>
<dl class="simple">
<dt>}, (error) =&gt; {</dt><dd><p>console.log(error);</p>
</dd>
</dl>
<p>});</p>
<p>// Output (in 90% of the cases)</p>
<p>// resolving the promise …
// Hello, Promises!
// Hello, Promises!
—-</p>
<p>.then() accepts two callbacks. The first callback is invoked when the promise is <strong>resolved</strong>. The second callback is executed when the promise is <strong>rejected</strong>.</p>
<p>Two functions are defined on line 10 and 11, onResolved and onRejected. They are passed as callbacks to the .then() on line 13. You can also use the more idiomatic style of writing a .then as done in line 16 to 20. It offers the same functionality as the above .then.</p>
<p>A few <strong>important</strong> things to note in the previous example.</p>
<p>We created a promise myPromise. We attached a .then handler two times: on line 13, and 16. Though, they are same in functionality, they are treated as different handlers. However —</p>
<blockquote>
<div><ul class="simple">
<li><p>A promise can only succeed(resolved) or fail(reject) once. It cannot succeed or fail twice, neither can it switch from success to failure or vice versa.</p></li>
<li><p>If a promise has succeeded or failed and you later add a success/failure callback (i.e a .then), the correct callback will be called, even though the event took place earlier.</p></li>
</ul>
</div></blockquote>
<p>That means once the promise reaches a final state, the state won’t change (that is, the computation will not be done again ) even if you attach .then handler multiple times.</p>
<p>To verify this, you can see a console.log statement on line 3. When you run the above code with both .then handler, the logged statement will be printed only once. <strong>It shows that the promise __caches__ the result, and will give the same result next time</strong>.</p>
<p>The other important thing to note is that a promise is link:https://en.wikipedia.org/wiki/Eager_evaluation[evaluated eagerly]. <strong>It starts its execution as soon as you declare and bind it to a variables</strong>. There is no .start or .begin method. Like it began in the previous example.</p>
<p>To ensure that promises are not fired immediately but evaluates lazily, <strong>we wrap them in functions</strong>. We’ll see an example of this later.</p>
<p>== Catching Promises</p>
<p>Till now we conveniently saw only the resolve cases. What happens when an error occurs in the __executor__ function. When an error occurs, the second callback of .then(), that is, onRejected is executed. Let’s see an example —</p>
</div>
<div class="section" id="id5">
<h2>[source,javascript]<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>const myProimse = new Promise((resolve, reject) =&gt; {</dt><dd><dl class="simple">
<dt>if (Math.random() * 100 &lt; 90) {</dt><dd><p>reject(new Error(‘The promise was rejected by using reject function.’));</p>
</dd>
</dl>
<p>}
throw new Error(‘The promise was rejected by throwing an error’);</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>myProimse.then(</dt><dd><p>() =&gt; console.log(‘resolved’),
(error) =&gt; console.log(error.message)</p>
</dd>
</dl>
<p>);</p>
<p>// Output (in 90% of cases)</p>
</div>
<div class="section" id="the-promise-was-rejected-by-using-reject-function">
<h2>// The promise was rejected by using reject function.<a class="headerlink" href="#the-promise-was-rejected-by-using-reject-function" title="Permalink to this headline">¶</a></h2>
<p>It’s the same as first example, but now it <strong>rejects</strong> with 90 percent probability and throws an error in 10% of the cases.</p>
<p>On line 10 and 11 we have defined onResolved and onRejected callbacks , respectively. Note that onRejected will be executed even if an error was thrown. It’s not necessary to reject a promise by passing an error in the reject function. That is, a promise is reject in both cases.</p>
<p>Since error handling is a necessity for robust programs, a shortcut is given for such a case. Instead of writing .then(null, () =&gt; {…}) when we want to handle an error, we can use .catch(onRejected) which accepts one callback: onRejected. Here’s how the above code will look with a catch handler —</p>
</div>
<div class="section" id="id6">
<h2>[source,javascript]<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>myPromise.catch(</dt><dd><p>(error) =&gt; console.log(error.message)</p>
</dd>
</dl>
</div>
<div class="section" id="id7">
<h2>);<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h2>
<p>Remember that .catch is just a link:https://en.wikipedia.org/wiki/Syntactic_sugar[syntactical sugar] for .then(undefined, onRejected).</p>
<p>== Chaining Promises</p>
<p>.then() and .catch() <strong>methods always return a promise</strong>. So you can chain multiple .then calls together. Let’s understand it by an example.</p>
<p>First, we create a delay function that returns a promise. The returned promise will resolve after the given number of seconds. Here’s its implementation —</p>
</div>
<div class="section" id="id8">
<h2>[source,javascript]<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>const delay = (ms) =&gt; new Promise(</dt><dd><p>(resolve) =&gt; setTimeout(resolve, ms)</p>
</dd>
</dl>
</div>
<div class="section" id="id9">
<h2>);<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>In this example, we are using a function to wrap our promise so that it does not execute immediately. The delay function accepts the time in milliseconds as a parameter. The executor function has access to the ms parameter due to link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures[closure]. It also contains a setTimeout that calls the resolve function after ms milliseconds pass, <strong>effectively resolving the promise</strong>. Here’s an example usage —</p>
</div>
<div class="section" id="id10">
<h2>[source,javascript]<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="delay-5000-then-console-log-resolved-after-5-seconds">
<h2>delay(5000).then(() =&gt; console.log(‘Resolved after 5 seconds’));<a class="headerlink" href="#delay-5000-then-console-log-resolved-after-5-seconds" title="Permalink to this headline">¶</a></h2>
<p>The statements in the .then callback will run only after delay(5000) resolves. When you run the above code, you’ll see Resolved after 5 seconds printed five seconds later.</p>
<p>Here’s how we can chain multiple .then() calls —</p>
</div>
<div class="section" id="id11">
<h2>[source,javascript]<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>const delay = (ms) =&gt; new Promise(</dt><dd><p>(resolve) =&gt; setTimeout(resolve, ms)</p>
</dd>
</dl>
<p>);</p>
<dl>
<dt>delay(2000)</dt><dd><dl class="simple">
<dt>.then(() =&gt; {</dt><dd><p>console.log(‘Resolved after 2 seconds’)
return delay(1500);</p>
</dd>
</dl>
<p>})
.then(() =&gt; {</p>
<blockquote>
<div><p>console.log(‘Resolved after 1.5 seconds’);
return delay(3000);</p>
</div></blockquote>
<dl class="simple">
<dt>}).then(() =&gt; {</dt><dd><p>console.log(‘Resolved after 3 seconds’);
throw new Error();</p>
</dd>
<dt>}).catch(() =&gt; {</dt><dd><p>console.log(‘Caught an error.’);</p>
</dd>
<dt>}).then(() =&gt; {</dt><dd><p>console.log(‘Done.’);</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>// Resolved after 2 seconds
// Resolved after 1.5 seconds
// Resolved after 3 seconds
// Caught an error.
// Done.
—-</p>
<p>We begin at line 5. The steps undertaken are —</p>
<blockquote>
<div><ul class="simple">
<li><p>The delay(2000) function returns a promise that gets resolved after two seconds.</p></li>
<li><p>The first .then() executes. It logs a sentence Resolved after 2 seconds. Then, it return another promise by calling delay(1500). If a .then() returns a promise, the __resolution__ (technically called settlement) of the that promise is forwarded to next .then call.</p></li>
<li><p>This continues as long as the chain is.</p></li>
</ul>
</div></blockquote>
<p><strong>Also note line 15</strong>. We are throwing an error in the .then. That means the current promise is rejected, and <strong>is caught in the next .catch handler</strong>. Hence, Caught an error gets printed. However, a .catch <strong>itself is always __resolved__ as a promise, and not rejected</strong> (unless you intentionally throw an error). That’s why the .then following .catch is executed.</p>
<p>It is recommended to use .catch and not .then with both onResolved and onRejected parameters. Here’s a case explaining why —</p>
</div>
<div class="section" id="id12">
<h2>[source,javascript]<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>const promiseThatResolves = () =&gt; new Promise((resolve, reject) =&gt; {</dt><dd><p>resolve();</p>
</dd>
</dl>
<p>});</p>
<p>// Leads to UnhandledPromiseRejection
promiseThatResolves().then(</p>
<blockquote>
<div><p>() =&gt; { throw new Error },
(err) =&gt; console.log(err),</p>
</div></blockquote>
<p>);</p>
<p>// Proper error handling
promiseThatResolves()</p>
<blockquote>
<div><dl class="simple">
<dt>.then(() =&gt; {</dt><dd><p>throw new Error();</p>
</dd>
</dl>
<p>})
.catch(err =&gt; console.log(err));</p>
</div></blockquote>
<hr class="docutils" />
<p>Line 1 creates a promise that always resolves. When you have a .then with two callbacks, onResolved and onRejected, you can only handle errors and rejections of the <strong>//executor//</strong> function. Suppose that the handler in .then also throws an error. It won’t lead to the execution of onRejected callback as shown on lines 6–9.</p>
<p>But if you have a .catch a level below the .then, then the .catch <strong>catches errors of executor function and the errors of</strong> .then handler too. It makes sense because .then always returns a promise. It is shown on line 12–16.</p>
<p>You can execute all the code samples, and learn more by doing. A good way to learn is by implementing callback-based functions into promises. If you work with Node, a lot of functions in fs and other modules are callback-based. There do exist utilities that can automatically convert a callback-based function to promises such as Node’s link:https://nodejs.org/api/util.html#util_util_promisify_original[util.promisify] and link:https://github.com/sindresorhus/pify[pify]. But, if you are learning, consider applying the WET (Write Everything Twice) principle and re-implement or read the code of as much libraries/functions as possible. Use link:https://en.wikipedia.org/wiki/Don%27t_repeat_yourself[DRY] (Don’t Repeat Yourself) principle every other time especially in production.</p>
<p>There are many other things that I have not been able to cover such as Promise.all, Promise.race and other static methods. Handling errors in promises, and some common anti-patterns and gotchas to be aware while making a promise. You can reference the below articles for a more understanding on these topics.</p>
<p>Do respond to this article if you want me to cover those topics in another article! :)</p>
<p>== References</p>
<p>link:http://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects[ECMA Promise Specification], link:https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise[Mozilla Docs], link:https://developers.google.com/web/fundamentals/primers/promises#promise-api-reference[Google’s Developer’s Guide on Promises] written by Jake Archibald, link:http://exploringjs.com/es6/ch_promises.html#sec_first-example-promises[Exploring JS’s Chapter on Promises], and link:http://jamesknelson.com/grokking-es6-promises-the-four-functions-you-need-to-avoid-callback-hell/[Introduction to Promises].
I hope you enjoyed this guest post! This article was written by Arfat Salmon exclusively for CodeBurst.io</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="boost_your_crowdfunding_campaign_with_these_10_tips.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="6 ways to increase buy-in from project stakeholders.html" title="6 ways to increase buy-in from project stakeholders"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Enterprise Architecture  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Peter Preeper.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>