

<!doctype html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>[NOTE] &#8212; Enterprise Architecture  documentation</title>
    <link rel="stylesheet" href="../_static/bizstyle.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/language_data.js"></script>
    <script type="text/javascript" src="../_static/bizstyle.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="&lt;no title&gt;" href="How To Add A Custom Domain In Github Pages.html" />
    <link rel="prev" title="&lt;no title&gt;" href="how_i_went_from_newbie_to_software_engineer_in_9_months_while_working_full_time.html" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0">
    <!--[if lt IE 9]>
    <script type="text/javascript" src="_static/css3-mediaqueries.js"></script>
    <![endif]-->
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="How To Add A Custom Domain In Github Pages.html" title="&lt;no title&gt;"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="how_i_went_from_newbie_to_software_engineer_in_9_months_while_working_full_time.html" title="&lt;no title&gt;"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Enterprise Architecture  documentation</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">[NOTE]</a></li>
<li><a class="reference internal" href="#if-you-havent-witnessed-the-machine-box-developer-experience-yet-please-give-it-a-go-and-let-me-know-what-you-think">If you haven’t witnessed the Machine Box developer experience yet, please give it a go and let me know what you think.</a><ul>
<li><a class="reference internal" href="#source-go">[source,go]</a></li>
<li><a class="reference internal" href="#id5">}</a></li>
<li><a class="reference internal" href="#id6">[source,go]</a></li>
<li><a class="reference internal" href="#id9">}</a></li>
<li><a class="reference internal" href="#id10">[source,go]</a></li>
<li><a class="reference internal" href="#func-s-server-handlesomething-http-handlerfunc">func (s *server) handleSomething() http.HandlerFunc { … }</a></li>
<li><a class="reference internal" href="#id13">[source,go]</a></li>
<li><a class="reference internal" href="#id18">}</a></li>
<li><a class="reference internal" href="#id19">[source,go]</a></li>
<li><a class="reference internal" href="#id24">}</a></li>
<li><a class="reference internal" href="#id25">[source,go]</a></li>
<li><a class="reference internal" href="#id30">}</a></li>
<li><a class="reference internal" href="#id31">[source,go]</a></li>
<li><a class="reference internal" href="#id36">}</a></li>
<li><a class="reference internal" href="#id37">[source,go]</a></li>
<li><a class="reference internal" href="#id40">}</a></li>
<li><a class="reference internal" href="#id41">[source,go]</a></li>
<li><a class="reference internal" href="#id46">}</a></li>
<li><a class="reference internal" href="#id47">[source,go]</a></li>
<li><a class="reference internal" href="#id50">[source,go]</a></li>
<li><a class="reference internal" href="#id57">}</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id58">[NOTE]</a></li>
<li><a class="reference internal" href="#remember-that-doing-this-you-are-moving-the-initialisation-time-from-startup-to-runtime-when-the-endpoint-is-first-accessed-i-use-google-app-engine-a-lot-so-this-makes-sense-for-me-but-your-case-might-be-different-so-its-worth-thinking-about-where-and-when-to-use-sync-once-in-this-way">Remember that doing this, you are moving the initialisation time from startup, to runtime (when the endpoint is first accessed). I use Google App Engine a lot, so this makes sense for me, but your case might be different so it’s worth thinking about where and when to use sync.Once in this way.</a><ul>
<li><a class="reference internal" href="#id59">[source,go]</a></li>
<li><a class="reference internal" href="#id62">}</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="how_i_went_from_newbie_to_software_engineer_in_9_months_while_working_full_time.html"
                        title="previous chapter">&lt;no title&gt;</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="How To Add A Custom Domain In Github Pages.html"
                        title="next chapter">&lt;no title&gt;</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/misc/How I write Go HTTP services after seven years.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <p>= How I write Go HTTP services after seven years</p>
<p>I’ve been writing Go (Golang when not spoken) since r59 — a pre 1.0 release — and have been building HTTP APIs and services in Go for the past seven years.</p>
<p>At Machine Box, most of my technical work involves building various APIs. Machine Learning is complicated and inaccessible to most developers, so my job is to tell a simple story through the API endpoints, and we’ve had great feedback so far.</p>
<div class="section" id="note">
<h1>[NOTE]<a class="headerlink" href="#note" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="if-you-havent-witnessed-the-machine-box-developer-experience-yet-please-give-it-a-go-and-let-me-know-what-you-think">
<h1>If you haven’t witnessed the Machine Box developer experience yet, please give it a go and let me know what you think.<a class="headerlink" href="#if-you-havent-witnessed-the-machine-box-developer-experience-yet-please-give-it-a-go-and-let-me-know-what-you-think" title="Permalink to this headline">¶</a></h1>
<p>The way I have written services has changed over the years, so I wanted to share how I write the services today — in case the patterns are useful to you and your work.</p>
<p>== A server struct</p>
<p>All of my components have a single <cite>server</cite> structure that usually ends up looking something like this:</p>
<div class="section" id="source-go">
<h2>[source,go]<a class="headerlink" href="#source-go" title="Permalink to this headline">¶</a></h2>
<dl class="simple">
<dt>type server struct {</dt><dd><p>db     <a href="#id1"><span class="problematic" id="id2">*</span></a>someDatabase
router <a href="#id3"><span class="problematic" id="id4">*</span></a>someRouter
email  EmailSender</p>
</dd>
</dl>
</div>
<div class="section" id="id5">
<h2>}<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Shared dependencies are fields of the structure</p></li>
</ul>
<p>== routes.go</p>
<p>I have a single file inside every component called <cite>routes.go</cite> where all the routing can live:</p>
</div>
<div class="section" id="id6">
<h2>[source,go]<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>package app
func (s <a href="#id7"><span class="problematic" id="id8">*</span></a>server) routes() {</p>
<blockquote>
<div><p>s.router.HandleFunc(“/api/”, s.handleAPI())
s.router.HandleFunc(“/about”, s.handleAbout())
s.router.HandleFunc(“/”, s.handleIndex())</p>
</div></blockquote>
</div>
<div class="section" id="id9">
<h2>}<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h2>
<p>This is handy because most code maintenance starts with a URL and an error report — so one glance at <cite>routes.go</cite> will direct us where to look.</p>
<p>== Handlers hang off the server</p>
<p>My HTTP handlers hang off the server:</p>
</div>
<div class="section" id="id10">
<h2>[source,go]<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="func-s-server-handlesomething-http-handlerfunc">
<h2>func (s <a href="#id11"><span class="problematic" id="id12">*</span></a>server) handleSomething() http.HandlerFunc { … }<a class="headerlink" href="#func-s-server-handlesomething-http-handlerfunc" title="Permalink to this headline">¶</a></h2>
<p>Handlers can access the dependencies via the <cite>s</cite> server variable.</p>
<p>== Return the handler</p>
<p>My handler functions don’t actually handle the requests, they return a function that does.</p>
<p>This gives us a closure environment in which our handler can operate:</p>
</div>
<div class="section" id="id13">
<h2>[source,go]<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id14"><span class="problematic" id="id15">*</span></a>server) handleSomething() http.HandlerFunc {</dt><dd><p>thing := prepareThing()
return func(w http.ResponseWriter, r <a href="#id16"><span class="problematic" id="id17">*</span></a>http.Request) {</p>
<blockquote>
<div><p>// use thing</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id18">
<h2>}<a class="headerlink" href="#id18" title="Permalink to this headline">¶</a></h2>
<p>The <cite>prepareThing</cite> is called only once, so you can use it to do one-time per-handler initialisation, and then use the <cite>thing</cite> in the handler.</p>
<p>Be sure to only <em>read</em> the shared data, if handlers are modifying anything, remember you’ll need a mutex or something to protect it.</p>
<p>== Take arguments for handler-specific dependencies</p>
<p>If a particular handler has a dependency, take it as an argument.</p>
</div>
<div class="section" id="id19">
<h2>[source,go]<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id20"><span class="problematic" id="id21">*</span></a>server) handleGreeting(format string) http.HandlerFunc {</dt><dd><dl class="simple">
<dt>return func(w http.ResponseWriter, r <a href="#id22"><span class="problematic" id="id23">*</span></a>http.Request) {</dt><dd><p>fmt.Fprintf(w, format, “World”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id24">
<h2>}<a class="headerlink" href="#id24" title="Permalink to this headline">¶</a></h2>
<p>The <cite>format</cite> variable is accessible to the handlers.</p>
<p>== HandlerFunc over Handler</p>
<p>I use <cite>http.HandlerFunc</cite> in almost every case now, rather than <cite>http.Handler</cite>.</p>
</div>
<div class="section" id="id25">
<h2>[source,go]<a class="headerlink" href="#id25" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id26"><span class="problematic" id="id27">*</span></a>server) handleSomething() http.HandlerFunc {</dt><dd><dl class="simple">
<dt>return func(w http.ResponseWriter, r <a href="#id28"><span class="problematic" id="id29">*</span></a>http.Request) {</dt><dd><p>…</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id30">
<h2>}<a class="headerlink" href="#id30" title="Permalink to this headline">¶</a></h2>
<p>They are more or less interchangeable, so just pick whichever is simpler to read. For me, that’s <cite>http.HandlerFunc</cite>.</p>
<p>== Middleware are just Go functions</p>
<p>Middleware functions take an <cite>http.HandlerFunc</cite> and return a new one that can run code before and/or after calling the original handler — or it can decide not to call the original handler at all.</p>
</div>
<div class="section" id="id31">
<h2>[source,go]<a class="headerlink" href="#id31" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id32"><span class="problematic" id="id33">*</span></a>server) adminOnly(h http.HandlerFunc) http.HandlerFunc {</dt><dd><dl>
<dt>return func(w http.ResponseWriter, r <a href="#id34"><span class="problematic" id="id35">*</span></a>http.Request) {</dt><dd><dl class="simple">
<dt>if !currentUser(r).IsAdmin {</dt><dd><p>http.NotFound(w, r)
return</p>
</dd>
</dl>
<p>}
h(w, r)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id36">
<h2>}<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h2>
<p>The logic inside the handler can optionally decide whether to call the original handler or not — in the example above, if <cite>IsAdmin</cite> is <cite>false</cite>, the handler will return an HTTP <cite>404 Not Found</cite> and return (abort); notice that the <cite>h</cite> handler is <em>not</em> called.</p>
<p>If <cite>IsAdmin</cite> is <cite>true</cite>, execution is passed to the <cite>h</cite> handler that was passed in.</p>
<p>Usually I have middleware listed in the <cite>routes.go</cite> file:</p>
</div>
<div class="section" id="id37">
<h2>[source,go]<a class="headerlink" href="#id37" title="Permalink to this headline">¶</a></h2>
<p>package app
func (s <a href="#id38"><span class="problematic" id="id39">*</span></a>server) routes() {</p>
<blockquote>
<div><p>s.router.HandleFunc(“/api/”, s.handleAPI())
s.router.HandleFunc(“/about”, s.handleAbout())
s.router.HandleFunc(“/”, s.handleIndex())
s.router.HandleFunc(“/admin”, s.adminOnly(s.handleAdminIndex))</p>
</div></blockquote>
</div>
<div class="section" id="id40">
<h2>}<a class="headerlink" href="#id40" title="Permalink to this headline">¶</a></h2>
<p>== Request and response types can go in there too</p>
<p>If an endpoint has its own request and response types, usually they’re only useful for that particular handler.</p>
<p>If that’s the case, you can define them inside the function.</p>
</div>
<div class="section" id="id41">
<h2>[source,go]<a class="headerlink" href="#id41" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id42"><span class="problematic" id="id43">*</span></a>server) handleSomething() http.HandlerFunc {</dt><dd><dl class="simple">
<dt>type request struct {</dt><dd><p>Name string</p>
</dd>
</dl>
<p>}
type response struct {</p>
<blockquote>
<div><p>Greeting string <cite>json:”greeting”</cite></p>
</div></blockquote>
<p>}
return func(w http.ResponseWriter, r <a href="#id44"><span class="problematic" id="id45">*</span></a>http.Request) {</p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id46">
<h2>}<a class="headerlink" href="#id46" title="Permalink to this headline">¶</a></h2>
<p>This declutters your package space and allows you to name these kinds of types the same, instead of having to think up handler-specific versions.</p>
<p>In test code, you can just copy the type into your test function and do the same thing. Or…</p>
<p>== Test types can help frame the test</p>
<p>If your request/response types are hidden inside the handler, you can just declare new types in your test code.</p>
<p>This is an opportunity to do a bit of storytelling to future generations who will need to understand your code.</p>
<p>For example, let’s say we have a <cite>Person</cite> type in our code, and we reuse it on many endpoints. If we had a <cite>/greet</cite> endpoint, we might only care about their name, so we can express this in test code:</p>
</div>
<div class="section" id="id47">
<h2>[source,go]<a class="headerlink" href="#id47" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func TestGreet(t <a href="#id48"><span class="problematic" id="id49">*</span></a>testing.T) {</dt><dd><p>is := is.New(t)
p := struct {</p>
<blockquote>
<div><p>Name string <cite>json:”name”</cite></p>
</div></blockquote>
<dl class="simple">
<dt>}{</dt><dd><p>Name: “Mat Ryer”,</p>
</dd>
</dl>
<p>}
var buf bytes.Buffer
err := json.NewEncoder(&amp;buf).Encode(p)
is.NoErr(err) // json.NewEncoder
req, err := http.NewRequest(http.MethodPost, “/greet”, &amp;buf)
is.NoErr(err)
//… more test code here</p>
</dd>
</dl>
<hr class="docutils" />
<p>It’s clear from this test, that the only field we care about is the <cite>Name</cite> of the person.</p>
<p>== sync.Once to setup dependencies</p>
<p>If I have to do anything expensive when preparing the handler, I defer it until when that handler is first called.</p>
<p>This improves application startup time.</p>
</div>
<div class="section" id="id50">
<h2>[source,go]<a class="headerlink" href="#id50" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func (s <a href="#id51"><span class="problematic" id="id52">*</span></a>server) handleTemplate(files string…) http.HandlerFunc {</dt><dd><dl class="simple">
<dt>var (</dt><dd><p>init sync.Once
tpl  <a href="#id53"><span class="problematic" id="id54">*</span></a>template.Template
err  error</p>
</dd>
</dl>
<p>)
return func(w http.ResponseWriter, r <a href="#id55"><span class="problematic" id="id56">*</span></a>http.Request) {</p>
<blockquote>
<div><dl class="simple">
<dt>init.Do(func(){</dt><dd><p>tpl, err = template.ParseFiles(files…)</p>
</dd>
</dl>
<p>})
if err != nil {</p>
<blockquote>
<div><p>http.Error(w, err.Error(), http.StatusInternalServerError)
return</p>
</div></blockquote>
<p>}
// use tpl</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div>
<div class="section" id="id57">
<h2>}<a class="headerlink" href="#id57" title="Permalink to this headline">¶</a></h2>
<p><cite>sync.Once</cite> ensures the code is only executed one time, and other calls (other people making the same request) will block until it’s finished.</p>
<ul class="simple">
<li><p>The error check is outside of the <cite>init</cite> function, so if something does go wrong we still surface the error and won’t lose it in the logs</p></li>
<li><p>If the handler is not called, the expensive work is never done — this can have big benefits depending on how your code is deployed</p></li>
</ul>
</div>
</div>
<div class="section" id="id58">
<h1>[NOTE]<a class="headerlink" href="#id58" title="Permalink to this headline">¶</a></h1>
</div>
<div class="section" id="remember-that-doing-this-you-are-moving-the-initialisation-time-from-startup-to-runtime-when-the-endpoint-is-first-accessed-i-use-google-app-engine-a-lot-so-this-makes-sense-for-me-but-your-case-might-be-different-so-its-worth-thinking-about-where-and-when-to-use-sync-once-in-this-way">
<h1>Remember that doing this, you are moving the initialisation time from startup, to runtime (when the endpoint is first accessed). I use Google App Engine a lot, so this makes sense for me, but your case might be different so it’s worth thinking about where and when to use sync.Once in this way.<a class="headerlink" href="#remember-that-doing-this-you-are-moving-the-initialisation-time-from-startup-to-runtime-when-the-endpoint-is-first-accessed-i-use-google-app-engine-a-lot-so-this-makes-sense-for-me-but-your-case-might-be-different-so-its-worth-thinking-about-where-and-when-to-use-sync-once-in-this-way" title="Permalink to this headline">¶</a></h1>
<p>== The server is testable</p>
<p>Our server type is very testable.</p>
<div class="section" id="id59">
<h2>[source,go]<a class="headerlink" href="#id59" title="Permalink to this headline">¶</a></h2>
<dl>
<dt>func TestHandleAbout(t <a href="#id60"><span class="problematic" id="id61">*</span></a>testing.T) {</dt><dd><p>is := is.New(t)
srv := server{</p>
<blockquote>
<div><p>db:    mockDatabase,
email: mockEmailSender,</p>
</div></blockquote>
<p>}
srv.routes()
req, err := http.NewRequest(“GET”, “/about”, nil)
is.NoErr(err)
w := httptest.NewRecorder()
srv.ServeHTTP(w, req)
is.Equal(w.StatusCode, http.StatusOK)</p>
</dd>
</dl>
</div>
<div class="section" id="id62">
<h2>}<a class="headerlink" href="#id62" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Create a server instance inside each test — if expensive things lazy load, this won’t take much time at all, even for big components</p></li>
<li><p>By calling ServeHTTP on the server, we are testing the entire stack including routing and middleware, etc. You can of course call the handler methods directly if you want to avoid this</p></li>
<li><p>Use <cite>httptest.NewRecorder</cite> to record what the handlers are doing</p></li>
<li><p>This code sample uses my link:https://godoc.org/github.com/matryer/is[is testing mini-framework] (a mini alternative to Testify)</p></li>
</ul>
<p>== Conclusion</p>
<p>I hope the items I covered in this post make sense, and help you in your work. If you disagree or have other ideas, link:https://twitter.com/matryer[please tweet me].</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="How To Add A Custom Domain In Github Pages.html" title="&lt;no title&gt;"
             >next</a> |</li>
        <li class="right" >
          <a href="how_i_went_from_newbie_to_software_engineer_in_9_months_while_working_full_time.html" title="&lt;no title&gt;"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">Enterprise Architecture  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Peter Preeper.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.2.1.
    </div>
  </body>
</html>